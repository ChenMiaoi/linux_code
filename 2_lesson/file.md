# 进程
	承担分配系统资源的基本实体
# 线程
	在一个程序里的一个执行路线就叫做线程(tread)。线程是"一个进程内部的控制序列"
	是调度的基本单位，线程是进程里面的执行流(线程在进程的地址空间内运行)

进程：线程 = 1：n

Linux中没有真正意义上的线程！线程是用进程模拟的(没有专门为线程设置底层数据结构) -- 依旧使用task_struct表示 -- 轻量级进程
Windows有一个TCB的线程数据结构
透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每一个执行流，就形成了线程执行流

# 线程的优点  

	1. 创建一个线程的代价比创建一个进程小的多
	2. 与进程之间的切换相比，线程切换操作系统需要做的工作少的多
	3. 线程占用的资源比进程少
	4. 能充分利用多处理器的可并行数量
	5. 在等待慢速I/O操作结束的同时，程序可执行其他的计算机任务
	6. 计算密集型应用，为了能够在多处理器系统上运行，将计算分解到多个线程中实现
	7. I/O密集型应用，为了提高性能，将I/O操作重叠。线程能够同时等待不同I/O操作

# 线程的缺点  

	1. 性能缺失
		一个很少被外部事件阻塞的计算机密集型线程往往无法与其他线程共享一个处理器。
		这里的性能缺失指的是增加了额外的同步和调度开销，而可用的资源不变
	2. 健壮性降低
		线程之间是缺乏保护的。在一个多线程程序里面，因时间分配上的细微偏差或者
		因共享了不该共享的的变量而造成不良影响的可能性是很大的
	3. 缺乏访问控制
		进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响
	4. 编程难度高
		编写与调试一个多线程程序比但单线程程序困难的多

# 线程异常  

	1. 单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随之崩溃
	2. 线程是进程的执行分支，线程出现异常，就类似进程出异常，进而触发信号机制，终止进程，进程中止，该进程内的所有线程也就随即退出

# 线程用途  

	1. 合理的使用多线程，能提高CPU密集型程序的执行效率
	2. 合理的使用多线程，能提高IO密集型程序的用户体验
	
# 进程 & 线程  

	1. 进程是资源分配的基本单位
	2. 线程是调度的基本单位
	3. 线程共享进程数据，但也有自己的数据：
		a. 线程ID
		b. 一组寄存器(上下文)	-- 重要
		c. 栈					-- 重要
		d. errno
		e. 信号屏蔽字
		f. 调度优先级

# 进程的多个线程共享  

	- 同一地址空间，定义的函数，全局变量都能够访问，除此之外：
		1. 文件描述符表
		2. 每种信号的处理方式(SIG_IGN、SIG_DFL或者自定义的信号处理函数)
		3. 当前工作目录
		4. 用户ID和组ID

# POSIX -- NPTL原生线程库  

- pthread	-- 需要指定链接-pthread
    - int pthread_create(pthread_t\* thread, const pthread_attr_t\* attr, void \*(\*statr_routine)(void\*), void\* arg);
        - typedef pthread_t unsigned long int
    - pthread_t pthread_self(void);
        - 所谓的线程ID，就是线程在线程库线程控制块的起始位置
- 线程等待
	- pthread-join(pthread_t thread, void\*\* retval);

- 线程退出
	- pthread_exit(void\* retval);

- 线程取消
	- pthread_cancel(pthread_t thread);
		- 返回值的类型是一个宏：PTHREAD_CANCELED
		``` C
		#define PTHREAD_CANCELED (void\*)-1
		```


