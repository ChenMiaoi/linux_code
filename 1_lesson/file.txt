1.实际执行信号的处理动作被称为信号递达
2.信号从产生到递达之间的状态被称为信号未决
3.进程可以选择阻塞某个信号
4.被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作
5.注意，阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理操作

操作系统是通过位图来发送和接受信号的。
block表记录的是信号是否需要被阻塞
pending表记录的是信号是否被屏蔽/阻塞信息：
	1.位置代表是谁？哪一个信号
	2.内容代表是否？
handler表是一个函数指针表，每一个位置都是一个函数指针
	类似于：sighandler_t signal(int signum, sighandler_t handler);(更改一个进程递达的处理动作)

一个信号可以在未决之前就被屏蔽

# sudo grep -ER "SIG_DFL" /usr/include | less
找到信号的宏 -- 在signal-defs.h中

sigset_t:
	每个信号只有一个bit的未决标志，不会记录信号产生了多少次。因此，阻塞和未决使用了相同的数据类型sigset_t来存储，表示有效或无效。因此，使用者想要操作该数据类型只能通过下列系统提供的函数操作。其他类型属于无效输入

sigset_t信号集：
	int sigemptyset(sigset_t* set);
		#初始化set所指向的信号集，使所有信号对应的bit置零。

	int sigfillset(sigset_t* set);
		#初始化set所指向的信号集，使所有信号对应的bit为1

	int sigaddset(sigset_t* set, int signo);
		#设置set所指向的信号集中的signo位置的bit位信号为1

	int sigdelset(sigset_t* set, int signo);
		#设置set所指向的信号集中的signo位置的bit位信号为0

	int sigismember(sigset_t* set, int signo);
		#判定signo位置的信号是否在set指向的信号集中
##注意：在任何操作前，必须通过sigismember或者sigfillset初始化。同时禁止一切的位操作符
